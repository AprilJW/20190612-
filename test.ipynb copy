{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "import jieba\n",
    "import jieba.posseg as pseg\n",
    "from jieba import analyse\n",
    "import os\n",
    "from scipy.spatial.distance import pdist"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [],
   "source": [
    "str_a = '争专利争渠道,格力电器和奥克斯谁赢得多'\n",
    "str_b = '格力电器举报奥克斯,同行监督拿质量说事值得肯定'\n",
    "str_c = '格力电器详解举报奥克斯,巨头互撕为哪般'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['多', '举报', '同行', '巨头', '赢得', '谁', '值得', '专利', '格力电器', '互', '哪般', '质量', '监督', '为', '拿', '奥克斯', '争', '渠道', '撕', '说事', '和', '详解', '肯定'] 23\n",
      "[1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0] 23\n",
      "[0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1] 23\n",
      "[0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0] 23\n",
      "欧式距离:  3.872983346207417 3.7416573867739413 3.605551275463989\n",
      "余弦距离: 0.7891814893221081 0.7777777777777778 0.683772233983162\n"
     ]
    }
   ],
   "source": [
    "#jieba分词，计算欧式和余弦距离\n",
    "#a_list = jieba.lcut(str_a, cut_all = True)\n",
    "#a_list = jieba.lcut_for_search(str_a)\n",
    "a_list = jieba.lcut(str_a)\n",
    "b_list = jieba.lcut(str_b)\n",
    "c_list = jieba.lcut(str_c)\n",
    "seg_list = a_list + b_list + c_list\n",
    "seg_list_tem = list(set(seg_list))\n",
    "seg_list =[i for i in seg_list_tem if i != ',']\n",
    "print(seg_list, len(seg_list))\n",
    "def onehotlist(seg_list, str_list):\n",
    "    onehotlist = []\n",
    "    for i in seg_list:\n",
    "        if i in str_list:\n",
    "            onehotlist.append(1)\n",
    "        else:\n",
    "            onehotlist.append(0)\n",
    "    return(onehotlist)\n",
    "a_onehot = onehotlist(seg_list, a_list)\n",
    "print(a_onehot,len(a_onehot))\n",
    "b_onehot = onehotlist(seg_list, b_list)\n",
    "print(b_onehot,len(b_onehot))\n",
    "c_onehot = onehotlist(seg_list, c_list)\n",
    "print(c_onehot,len(c_onehot))\n",
    "a_array = np.array(a_onehot)\n",
    "b_array = np.array(b_onehot)\n",
    "c_array = np.array(c_onehot)\n",
    "\n",
    "#欧式距离\n",
    "a_b_distan = np.sqrt(np.sum(np.square(a_array - b_array)))\n",
    "a_c_distan = np.linalg.norm(a_array - c_array)\n",
    "#a_c_distan = np.sqrt(np.sum(np.square(a_array - c_array)))\n",
    "#c_b_distan = np.sqrt(np.sum(np.square(c_array - b_array)))\n",
    "c_b_distan = np.linalg.norm(c_array - b_array)\n",
    "print('欧式距离: ', a_b_distan, a_c_distan, c_b_distan)\n",
    "#余弦距离\n",
    "a_b_cos = 1 - np.dot(a_array, b_array)/(np.linalg.norm(a_array) * np.linalg.norm(b_array))\n",
    "a_c_cos = pdist(np.vstack([a_array, c_array]), 'cosine')[0]\n",
    "c_b_cos = pdist(np.vstack([b_array, c_array]), 'cosine')[0]\n",
    "print('余弦距离:', a_b_cos, a_c_cos, c_b_cos)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "max_match_num: 4\n",
      "match_str: 格力电器\n",
      "max_match_num: 4\n",
      "match_str: 格力电器\n",
      "max_match_num: 6\n",
      "match_str: 举报奥克斯,\n"
     ]
    }
   ],
   "source": [
    "#计算两个字符串最长公共子串\n",
    "def lcs(str_a, str_b):\n",
    "        lensum = float(len(str_a) + len(str_b))\n",
    "        #得到一个二维的数组，类似用dp[lena+1][lenb+1],并且初始化为0\n",
    "        ##lengths = [[0 for j in range(len(str_b)+1)] for i in range(len(str_a)+1)]\n",
    "        lengths = [[0 for j in range(len(str_b))] for i in range(len(str_a))]\n",
    "\n",
    "        max_num = 0\n",
    "        p = 0\n",
    "        #enumerate(a)函数： 得到下标i和a[i]\n",
    "        for i, x in enumerate(str_a):\n",
    "            for j, y in enumerate(str_b):\n",
    "                ##为什么x不向后移动一位呢, 因为不是从头开始匹配的？\n",
    "                if x == y:\n",
    "                    try:\n",
    "                        lengths[i][j] = lengths[i-1][j-1] + 1\n",
    "                        if max_num < lengths[i][j]:\n",
    "                            max_num = lengths[i][j]\n",
    "                            p = i\n",
    "\n",
    "                    except IndexError:\n",
    "                        lengths[i][j] = 1\n",
    "\n",
    "                    ##lengths[i+1][j+1] = lengths[i][j] + 1\n",
    "                else:\n",
    "                    pass\n",
    "                    ##lengths[i+1][j+1] = max(lengths[i+1][j], lengths[i][j+1])\n",
    "        print('max_match_num:', max_num)\n",
    "#         print('p:', p)\n",
    "#         print('len(str_a):', len(str_a))\n",
    "        print('match_str:', str_a[p+1-max_num: p + 1])\n",
    "#         longeststr = max(len(str_a), len(str_b))\n",
    "#         ratio = max_num / longeststr\n",
    "#         print(ratio)\n",
    "lcs(str_a, str_b)\n",
    "lcs(str_a, str_c)\n",
    "lcs(str_c, str_b)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "争专利争渠道,格力电器和奥克斯谁赢得多  到   格力电器举报奥克斯,同行监督拿质量说事值得肯定  编辑距离是：\n",
      "21\n",
      "争专利争渠道,格力电器和奥克斯谁赢得多  到   格力电器详解举报奥克斯,巨头互撕为哪般  编辑距离是：\n",
      "19\n",
      "格力电器举报奥克斯,同行监督拿质量说事值得肯定  到   格力电器详解举报奥克斯,巨头互撕为哪般  编辑距离是：\n",
      "15\n"
     ]
    }
   ],
   "source": [
    "#求一个字符串到另一个字符串最小编辑距离，从左到右从上到下，本函数的空间复杂度也为n*m,还有不同方向的实现方式，\n",
    "#以及空间复杂度位=为n的实现方式\n",
    "def minDistance(word1, word2):\n",
    "        n1 = len(word1)\n",
    "        n2 = len(word2)\n",
    "        #生成n1加1行，n2加1列矩阵\n",
    "        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n",
    "        \n",
    "        # 第一行，word2变成空字符串的最小编辑距离\n",
    "        for j in range(1, n2 + 1):\n",
    "            dp[0][j] = dp[0][j - 1] + 1\n",
    "            \n",
    "        # 第一列，word1变成空字符串的最小编辑距离\n",
    "        for i in range(1, n1 + 1):\n",
    "            dp[i][0] = dp[i - 1][0] + 1\n",
    "        \n",
    "        for i in range(1, n1 + 1):\n",
    "            for j in range(1, n2 + 1):\n",
    "                if word1[i - 1] == word2[j - 1]:\n",
    "                    dp[i][j] = dp[i - 1][j - 1]\n",
    "                else:\n",
    "                    #由word1变成word2,dp[i][j - 1]增加，dp[i - 1][j]删除， dp[i - 1][j - 1]替换\n",
    "                    dp[i][j] = min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1]) + 1\n",
    "        print('%s  到   %s  编辑距离是：' % (word1, word2))\n",
    "        print(dp[-1][-1])\n",
    "\n",
    "minDistance(str_a, str_b)\n",
    "#minDistance(str_b, str_a)\n",
    "minDistance(str_a, str_c)\n",
    "#minDistance(str_c, str_a)\n",
    "minDistance(str_b, str_c)\n",
    "#minDistance(str_c, str_b)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
